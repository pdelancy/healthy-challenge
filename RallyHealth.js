'use strict';

function Item(value) {
  this.value = value;
  this.next = null;
}

//A queue data structure execute breadth-first search implemented as a linked-list
function Queue() {
  this.head = null;
  this.tail = null;
  this.size = 0;

  this.push = (value) => {
    var item = new Item(value);
    if(this.tail === null){
      this.head = item;
      this.tail = item;
    } else {
      this.tail.next = item;
      this.tail = item;
    }
    this.size++;
  }

  this.pop = () => {
    let retVal = this.head.value;
    if(this.head === this.tail){
      this.head = null;
      this.tail = null;
    } else {
      this.head = this.head.next;
    }
    this.size--;
    return retVal;
  }

  this.getSize = () => {
    return this.size;
  }
}

//A graph data structure to record the relationships words
function Graph() {
  this.nodes = {};

  //Each node's key is the word itself and its value is an object containing the
  //words it is directly related to
  this.addNode = (node) => {
    this.nodes[node] = {};
  }

  // Add a connection in the graph between two words. transformType is a number
  // netween 1 and 4 indicating what type of words transformation connects the
  // two words (1: add a letter, 2: remove a letter, 3: switch a letter, 4:
  // reorder word)
  this.addEdge = (node1, node2, transformType) => {
    //If node does not already exist, create a new one
    if(!this.nodes[node1]){
      this.nodes[node1] = {};
    }
    this.nodes[node1][node2] = transformType;
  }

  //Get every word one node is directly related to
  this.getNeighbors = (node) => {
    return Object.keys(this.nodes[node]);
  }

  //Check if a word is a node in the graph
  this.isNode = (word) => {
    return this.nodes[word];
  }

  // Find the least expensie path between two words (start and end) based on the
  // cost of each transformation
  this.findPath = (start, end, costs) => {

    //Object to keep track of the path's current cost at the time of visiting a
    //specific node
    const visited = {};

    //converts costs to integers
    costs = costs.map((val) => parseInt(val))

    //Object to record when the path between start and end as well as its cost
    let found = {
      word: end,
      path: [],
      cost: 0,
    };

    start = start.toLowerCase();
    end = end.toLowerCase();

    if(start === end) return found;
    const queue = new Queue();

    //Begin the queue by adding each neighbor of the starting node, and records
    //the path it will take as well as the cost incurred
    this.getNeighbors(start).map((word)=>{
      queue.push({
        word: word,
        path:[start],
        cost: costs[this.nodes[start][word] - 1]
      });
    })

    //Search for new, less expensive paths while there are still elements in
    //the queue
    while(queue.getSize() > 0){

      //look at the first element of the queue
      var node = queue.pop();

      //record
      visited[node.word] = node.cost;

      //If the node is the end word, check if the cost of this path is the least
      //expensive path found or the first path found.
      if(node.word === end && (!found.cost || (node.cost) < found.cost)) {
        found = Object.assign({}, node);
      } else {
        //If not, iterate through the current node's neighbors, and add each
        //neighbor, with an updated path and cost, to the queue.
        this.getNeighbors(node.word).map((word) => {
          const currentCost = node.cost + costs[this.nodes[node.word][word] - 1];
          if(!node.path.includes(word) &&
            //If the node has already been visited on a path with a lower cost,
            //do not add it to the queue
            (!visited[word] || currentCost < visited[word]) &&
            //If the current cost of the path has exceeded the cost of a working
            //path between start and end, do not add it to the queue
            (!found.cost || currentCost < found.cost)) {
            queue.push({
                word: word,
                path: [...node.path, node.word],
                cost: currentCost
              })
          }
        })
      }
    }

    //return the found path and cost, or, if no path has been found, return -1
    return found.cost ? found : -1;
  }
}

//Upon loading the page, instantiate a new graph and preprocess the word list to
//populate the graph
const graph = new Graph();

//To process the word list more quickly, group the words into word groups,
//categorizing words that have the same root. For example, the word group
//named '+osts' contains all words that can be generated by substituting a
//letter for '+'.
const wordGroups = {};
  // result.split('\n')
$('.words').text().split(' ').map((word1) => {
  word1 = word1.trim();
  if(word1.length > 2){
    graph.addNode(word1);
    const sortedWord = word1.split('').sort().join('');

    // Put the word in its appropriate category
    if(wordGroups[sortedWord]){
      wordGroups[sortedWord].map((word2) => {
        graph.addEdge(word1, word2, 4);
        graph.addEdge(word2, word1, 4);
      });
      wordGroups[sortedWord].push(word1)
    } else {
      wordGroups[sortedWord] = [word1];
    }

    //Iterate through each letter in the word
    for(let i = 0; i <= word1.length; i++){
      let addLetter = word1.slice(0, i) + '+' + word1.slice(i, word1.length);
      let subtractLetter = word1.slice(0, i) + '+' + word1.slice(i+1, word1.length);
      let slicedWord = word1.slice(0, i) + word1.slice(i + 1, word1.length);

      //Check if adding a letter at each location would create a word, based on created word groups
      if(wordGroups[addLetter]){
        wordGroups[addLetter].map((word2) => {
          //If yes, add an edge in the graph between each word in the word group and word1
          //Add an addition edge from word1 to word in word group
          graph.addEdge(word1, word2, 1);
          //Add a subtraction edge from word in word group to word1
          graph.addEdge(word2, word1, 2);
        });
      }

      //Exclude the last iteration because that would exceed the length of the word
      if( i < word1.length){
        //Check if sliced word creates a word
        if(graph.isNode(slicedWord)){
          //If yes, add corresponding subtraction and addition edges
          graph.addEdge(word1, slicedWord, 2);
          graph.addEdge(slicedWord, word1, 1);
        }
        //Check if switching current letter for a different one would create a word
        if(wordGroups[subtractLetter] ){
          //If yes, add switch letter edges to all existing words
          wordGroups[subtractLetter].map((word2) => {
            graph.addEdge(word1, word2, 3);
            graph.addEdge(word2, word1, 3);
          });
          //Add current word to word group
          wordGroups[subtractLetter].push(word1)
        } else {
          //If no, create a new word group
          wordGroups[subtractLetter] = [word1];
        }
      }
    }
  }
});

//jQuery code to interact with the html page
$('.submit').on('click', function(){
  const costs = $('#costs').val().trim().split(" ").map((cost) => {
    if(!isNaN(parseInt(cost))) return parseInt(cost);
  }).filter(cost => cost);
  if(costs.length !== 4){
    alert('Illegal cost input values')
  } else if(!(graph.isNode($('#start').val().toLowerCase().trim()) && graph.isNode($('#end').val().toLowerCase().trim()))){
    alert('Input words not found in dictionary')
  } else {
    if($('.result-data')) $('.result-data').remove();
    let result = graph.findPath($('#start').val(), $('#end').val(), costs);
    $('#start').val('');
    $('#end').val('');
    let path = result.path ? result.path.reduce((string, next) => (string + `${next} - `), '') + `${result.word}` : null;
    if(path) {
      $('.result').append(`
        <div class='result-data'>
          <div class='result-cost'>Cost: ${result.cost}</div>
          <div class='result-path'>Path: ${path} </div>
        </div>
      `)
    } else {
      $('.result').append(`
        <div class='result-data'>
          <div class='not-found'>No path found</div>
        </div>
      `)
    }
  }
})
